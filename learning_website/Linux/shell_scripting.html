<html><h2><u><center>Shell Scripting</center></u></h2>
<h4><pre>
-> Shell is an environment in which we can run our commands, programs, and shell scripts. 
-> There are different flavors of a shell, just as there are different flavors of operating systems. 
-> Each flavor of shell has its own set of recognized commands and functions.

<h3><u>Shell Prompt -</u></h3>
-> The prompt, $, which is called the command prompt, is issued by the shell. 
-> While the prompt is displayed, you can type a command.
-> Shell reads your input after you press Enter. 
-> It determines the command you want executed by looking at the first word of your input. 
-> A word is an unbroken set of characters. 
-> Spaces and tabs separate words.
-> Following is a simple example of the date command, which displays the current date and time −

$date
Fri Jul 23 14:54:31 CDT 2021

-> You can customize your command prompt using the environment variable PS1.

<h3><u>Shell Types -</u></h3>
-> In Linux, there are two major types of shells −

1. Bourne shell −> If you are using a Bourne-type shell, the $ character is the default prompt.
2. C shell −> If you are using a C-type shell, the % character is the default prompt.

The Bourne Shell has the following subcategories −

a. Bourne shell (sh)
b. Korn shell (ksh)
c. Bourne Again shell (bash)
d. POSIX shell (sh)

The different C-type shells follow −

a. C shell (csh)
b. TENEX/TOPS C shell (tcsh)

<h3><u>Shell Scripts -</u></h3>
-> The basic concept of a shell script is a list of commands, which are listed in the order of execution. 
-> A good shell script will have comments, preceded by # sign, describing the steps.
-> Shell scripts and functions are both interpreted. This means they are not compiled.
-> A shell is a command-line interpreter and typical operations performed by shell scripts include file manipulation, program execution, and printing text.
-> A Shell provides you with an interface to the Linux system. It gathers input from you and executes programs based on that input. When a program finishes execution, it 
   displays that program's output.

<u>Example Script</u>
-> Assume we create a test.sh script. 
-> Note all the scripts would have the .sh extension. 
-> Before you add anything else to your script, you need to alert the system that a shell script is being started. 
-> This is done using the shebang construct. For example −

#!/bin/sh

-> This tells the system that the commands that follow are to be executed by the Bourne shell. 
-> It's called a shebang because the # symbol is called a hash, and the ! symbol is called a bang.
-> To create a script containing these commands, you put the shebang line first and then add the commands.

#!/bin/bash
pwd
ls

-> Save the above content and make the script executable −

$chmod +x test.sh

-> The shell script is now ready to be executed −

$./test.sh

<h3><u>Using Shell Variables -</u></h3>
-> A variable is a character string to which we assign a value. 
-> The value assigned could be a number, text, filename, device, or any other type of data.
-> A variable is nothing more than a pointer to the actual data. 
-> The shell enables you to create, assign, and delete variables.

<u>Variable Names -</u>
-> The name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).
-> By convention, Linux shell variables will have their names in UPPERCASE.
-> The following examples are valid variable names −

_ALI
TOKEN_A
VAR_1
VAR_2

-> Following are the examples of invalid variable names −

2_VAR
-VARIABLE
VAR1-VAR2
VAR_A!

-> The reason you cannot use other characters such as !, *, or - is that these characters have a special meaning for the shell.

<u>Defining Variables </u>
-> Variables are defined as follows −

variable_name=variable_value

-> Variables of this type are called scalar variables. 
-> A scalar variable can hold only one value at a time.
-> Shell enables you to store any value you want in a variable. For example −

VAR1="Zara Ali"
VAR2=100

<u>Accessing Values -</u>
-> To access the value stored in a variable, prefix its name with the dollar sign ($).
-> For example, the following script will access the value of defined variable NAME and print it on STDOUT −

#!/bin/sh

NAME="Sidd"
echo $NAME

<u>Read-only Variables</u>
-> Shell provides a way to mark variables as read-only by using the read-only command. 
-> After a variable is marked read-only, its value cannot be changed.
-> For example, the following script generates an error while trying to change the value of NAME −

#!/bin/sh

NAME="Zara Ali"
readonly NAME
NAME="Qadiri"

<u>Unsetting Variables</u>
-> Unsetting or deleting a variable directs the shell to remove the variable from the list of variables that it tracks. 
-> Once you unset a variable, you cannot access the stored value in the variable.
-> Following is the syntax to unset a defined variable using the unset command −

unset variable_name

-> Here is a simple example that demonstrates how the command works −

#!/bin/sh

NAME="Zara Ali"
unset NAME
echo $NAME

-> The above example does not print anything. You cannot use the unset command to unset variables that are marked readonly.

<u>Variable Types</u>
-> When a shell is running, three main types of variables are present −

1. Local Variables
-> A local variable is a variable that is present within the current instance of the shell. 
-> It is not available to programs that are started by the shell. 
-> They are set at the command prompt.

2. Environment Variables 
−> An environment variable is available to any child process of the shell. 
-> Some programs need environment variables in order to function correctly. 
-> Usually, a shell script defines only those environment variables that are needed by the programs that it runs.

3. Shell Variables 
−> A shell variable is a special variable that is set by the shell and is required by the shell in order to function correctly. 
-> Some of these variables are environment variables whereas others are local variables.

<u>Special Variables</u>
-> We have to be careful when we use certain non-alphanumeric characters in variable names. 
-> This is because those characters are used in the names of special Linux variables. 
-> These variables are reserved for specific functions.
-> For example, the $ character represents the process ID number, or PID, of the current shell −

$echo $$

-> Following list shows a number of special variables that you can use in your shell scripts −

1. $0
-> The filename of the current script.

2. $n
-> These variables correspond to the arguments with which a script was invoked. 
-> Here n is a positive decimal number corresponding to the position of an argument (the first argument is $1, the second argument is $2, and so on).

3. $#
-> The number of arguments supplied to a script.

4. $*
-> All the arguments are double quoted. If a script receives two arguments, $* is equivalent to $1 $2.

5. $@
-> All the arguments are individually double quoted. If a script receives two arguments, $@ is equivalent to $1 $2.

6. $?
-> The exit status of the last command executed.

7. $$
-> The process number of the current shell. For shell scripts, this is the process ID under which they are executing.

8. $!
-> The process number of the last background command.

<u>Command-Line Arguments</u>
-> The command-line arguments $1, $2, $3, ...$9 are positional parameters, with $0 pointing to the actual command, program, shell script, or function and $1, $2, $3, ...$9 as 
   the arguments to the command.
-> Following script uses various special variables related to the command line −

#!/bin/sh

echo "File Name: $0"
echo "First Parameter : $1"
echo "Second Parameter : $2"
echo "Quoted Values: $@"
echo "Quoted Values: $*"
echo "Total Number of Parameters : $#"

-> Here is a sample run for the above script −

$./test.sh Zara Ali
File Name : ./test.sh
First Parameter : Zara
Second Parameter : Ali
Quoted Values: Zara Ali
Quoted Values: Zara Ali
Total Number of Parameters : 2

<u>Special Parameters $* and $@</u>

-> There are special parameters that allow accessing all the command-line arguments at once. 
-> $* and $@ both will act the same unless they are enclosed in double quotes, "".
-> Both the parameters specify the command-line arguments. 
-> However, the "$*" special parameter takes the entire list as one argument with spaces between and the "$@" special parameter takes the entire list and separates it into 
   separate arguments.
-> We can write the shell script as shown below to process an unknown number of command line arguments with either the $* or $@ special parameters −

#!/bin/sh

for TOKEN in $*
do
   echo $TOKEN
done
Here is a sample run for the above script −

$./test.sh Zara Ali 10 Years Old
Zara
Ali
10
Years
Old


<u>Exit Status</u>
-> The $? variable represents the exit status of the previous command.
-> Exit status is a numerical value returned by every command upon its completion. 
-> As a rule, most commands return an exit status of 0 if they were successful, and 1 if they were unsuccessful.
-> Some commands return additional exit status for particular reasons. 
-> For example, some commands differentiate between kinds of errors and will return various exit values depending on the specific type of failure.

Following is the example of successful command −

$./test.sh Zara Ali
File Name : ./test.sh
First Parameter : Zara
Second Parameter : Ali
Quoted Values: Zara Ali
Quoted Values: Zara Ali
Total Number of Parameters : 2
$echo $?
0
$

<h3><u>Shell Arrays</u></h3>
-> A shell variable is capable enough to hold a single value. These variables are called scalar variables.
-> Shell supports a different type of variable called an array variable. 
-> This can hold multiple values at the same time. 
-> Arrays provide a method of grouping a set of variables. 
-> Instead of creating a new name for each variable that is required, you can use a single array variable that stores all the other variables.
-> All the naming rules discussed for Shell Variables would be applicable while naming arrays.

<u>Defining Array Values</u>
-> The difference between an array variable and a scalar variable can be explained as follows.
-> Suppose you are trying to represent the names of various students as a set of variables. Each of the individual variables is a scalar variable as follows −

NAME01="Zara"
NAME02="Qadir"
NAME03="Mahnaz"
NAME04="Ayan"
NAME05="Daisy"

-> We can use a single array to store all the above mentioned names. Following is the simplest method of creating an array variable. This helps assign a value to one of its 
   indices.

array_name[index]=value

-> Here array_name is the name of the array, index is the index of the item in the array that you want to set, and value is the value you want to set for that item.

NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"

-> If you are using the bash shell, here is the syntax of array initialization −

array_name=(value1 ... valuen)

<u>Accessing Array Values</u>
-> After you have set any array variable, you access it as follows −

${array_name[index]}

Program:
#!/bin/sh

NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"
echo "First Index: ${NAME[0]}"
echo "Second Index: ${NAME[1]}"
The above example will generate the following result −

$./test.sh

First Index: Zara
Second Index: Qadir

-> You can access all the items in an array in one of the following ways −

${array_name[*]}
${array_name[@]}

Program:

#!/bin/sh

NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"
echo "First Method: ${NAME[*]}"
echo "Second Method: ${NAME[@]}"
The above example will generate the following result −

$./test.sh
First Method: Zara Qadir Mahnaz Ayan Daisy
Second Method: Zara Qadir Mahnaz Ayan Daisy

<h3><u>Shell Basic Operators</u></h3>
-> There are various operators supported by each shell. 
-> We will discuss in detail about Bourne shell (default shell).

1. Arithmetic Operators
2. Relational Operators
3. Boolean Operators
4. String Operators
5. File Test Operators

-> Bourne shell didn't originally have any mechanism to perform simple arithmetic operations but it uses external programs, either awk or expr.

val=`expr 2 + 2`
echo "Total value : $val"

-> The following points need to be considered while adding −
-> There must be spaces between operators and expressions. For example, 2+2 is not correct; it should be written as 2 + 2.
-> The complete expression should be enclosed between ‘ ‘, called the backtick.

<u>1. Arithmetic Operators</u>
-> The following arithmetic operators are supported by Bourne Shell.

a. + (Addition) => Adds values on either side of the operator => `expr $a + $b` 
b. - (Subtraction) => Subtracts right hand operand from left hand operand => `expr $a - $b` 
c. * (Multiplication) => Multiplies values on either side of the operator => `expr $a \* $b`
d. / (Division) => Divides left hand operand by right hand operand => `expr $b / $a` 
e. % (Modulus) => Divides left hand operand by right hand operand and returns remainder => `expr $b % $a` 
f. = (Assignment) => Assigns right operand in left operand	=> a = $b 
g. == (Equality) => Compares two numbers, if both are same then returns true. => [ $a == $b ] 
h. != (Not Equality) => Compares two numbers, if both are different then returns true. => [ $a != $b ] 

-> It is very important to understand that all the conditional expressions should be inside square braces with spaces around them.
-> For example [ $a == $b ] is correct whereas, [$a==$b] is incorrect.
-> All the arithmetical calculations are done using long integers.

<u>Relational Operators</u>
-> Bourne Shell supports the following relational operators that are specific to numeric values. 
-> These operators do not work for string values unless their value is numeric.
-> For example, following operators will work to check a relation between 10 and 20 as well as in between "10" and "20" but not in between "ten" and "twenty".

a. -eq	Checks if the value of two operands are equal or not; if yes, then the condition becomes true.	[ $a -eq $b ] is not true.
b. -ne	Checks if the value of two operands are equal or not; if values are not equal, then the condition becomes true.	[ $a -ne $b ] is true.
c. -gt	Checks if the value of left operand is greater than the value of right operand; if yes, then the condition becomes true.	[ $a -gt $b ] is not true.
d. -lt	Checks if the value of left operand is less than the value of right operand; if yes, then the condition becomes true.	[ $a -lt $b ] is true.
e. -ge	Checks if the value of left operand is greater than or equal to the value of right operand; if yes, then the condition becomes true.	[ $a -ge $b ] is not true.
f. -le	Checks if the value of left operand is less than or equal to the value of right operand; if yes, then the condition becomes true.	[ $a -le $b ] is true.

-> It is very important to understand that all the conditional expressions should be placed inside square braces with spaces around them. 
-> For example, [ $a <= $b ] is correct whereas, [$a <= $b] is incorrect.

<u>Boolean Operators</u>
-> The following Boolean operators are supported by the Bourne Shell.

a. !	This is logical negation. This inverts a true condition into false and vice versa.	[ ! false ] is true.
b. -o	This is logical OR. If one of the operands is true, then the condition becomes true.	[ $a -lt 20 -o $b -gt 100 ] is true.
c. -a	This is logical AND. If both the operands are true, then the condition becomes true otherwise false.	[ $a -lt 20 -a $b -gt 100 ] is false.

<u>String Operators</u>
-> The following string operators are supported by Bourne Shell.
-> Assume variable a holds "abc" and variable b holds "efg" then −

a. =	Checks if the value of two operands are equal or not; if yes, then the condition becomes true.	[ $a = $b ] is not true.
b. !=	Checks if the value of two operands are equal or not; if values are not equal then the condition becomes true.	[ $a != $b ] is true.
c. -z	Checks if the given string operand size is zero; if it is zero length, then it returns true.	[ -z $a ] is not true.
d. -n	Checks if the given string operand size is non-zero; if it is nonzero length, then it returns true.	[ -n $a ] is not false.
e. str	Checks if str is not the empty string; if it is empty, then it returns false.	[ $a ] is not false.

<u>File Test Operators</u>
-> We have a few operators that can be used to test various properties associated with a Linux file.

a. -b file	Checks if file is a block special file; if yes, then the condition becomes true.	[ -b $file ] is false.
b. -c file	Checks if file is a character special file; if yes, then the condition becomes true.	[ -c $file ] is false.
c. -d file	Checks if file is a directory; if yes, then the condition becomes true.	[ -d $file ] is not true.
d. -f file	Checks if file is an ordinary file as opposed to a directory or special file; if yes, then the condition becomes true.	[ -f $file ] is true.
e. -g file	Checks if file has its set group ID (SGID) bit set; if yes, then the condition becomes true.	[ -g $file ] is false.
f. -k file	Checks if file has its sticky bit set; if yes, then the condition becomes true.	[ -k $file ] is false.
g. -p file	Checks if file is a named pipe; if yes, then the condition becomes true.	[ -p $file ] is false.
h. -t file	Checks if file descriptor is open and associated with a terminal; if yes, then the condition becomes true.	[ -t $file ] is false.
i. -u file	Checks if file has its Set User ID (SUID) bit set; if yes, then the condition becomes true.	[ -u $file ] is false.
j. -r file	Checks if file is readable; if yes, then the condition becomes true.	[ -r $file ] is true.
k. -w file	Checks if file is writable; if yes, then the condition becomes true.	[ -w $file ] is true.
l. -x file	Checks if file is executable; if yes, then the condition becomes true.	[ -x $file ] is true.
m. -s file	Checks if file has size greater than 0; if yes, then condition becomes true.	[ -s $file ] is true.
n. -e file	Checks if file exists; is true even if file is a directory but exists.	[ -e $file ] is true.

<h3><u>Shell Decision Making</u></h3>

-> While writing a shell script, there may be a situation when you need to adopt one path out of the given two paths. 
-> So you need to make use of conditional statements that allow your program to make correct decisions and perform the right actions.
-> Linux Shell supports conditional statements which are used to perform different actions based on different conditions. 
-> We will now understand two decision-making statements here −

1. The if...else statement
2. The case...esac statement

<u>The if...else statements</u>
-> If else statements are useful decision-making statements which can be used to select an option from a given set of options.
-> Linux Shell supports following forms of if…else statement −

1. if...fi statement

Syntax:

if [ expression ] 
then 
   Statement(s) to be executed if expression is true 
fi

2. if...else...fi statement

Syntax:

if [ expression ]
then
   Statement(s) to be executed if expression is true
else
   Statement(s) to be executed if expression is not true
fi

3. if...elif...else...fi statement

Syntax:

if [ expression 1 ]
then
   Statement(s) to be executed if expression 1 is true
elif [ expression 2 ]
then
   Statement(s) to be executed if expression 2 is true
elif [ expression 3 ]
then
   Statement(s) to be executed if expression 3 is true
else
   Statement(s) to be executed if no expression is true
fi

<u>The case...esac Statement</u>
-> You can use multiple if...elif statements to perform a multiway branch. 
-> However, this is not always the best solution, especially when all of the branches depend on the value of a single variable.
-> Linux Shell supports case...esac statement which handles exactly this situation, and it does so more efficiently than repeated if...elif statements.
-> There is only one form of case...esac statement which has been described in detail here −

Syntax:

case word in
   pattern1)
      Statement(s) to be executed if pattern1 matches
      ;;
   pattern2)
      Statement(s) to be executed if pattern2 matches
      ;;
   pattern3)
      Statement(s) to be executed if pattern3 matches
      ;;
   *)
     Default condition to be executed
     ;;
esac

-> The case...esac statement in the Linux shell is very similar to the switch...case statement we have in other programming languages like C or C++ and PERL, etc.

<h3><u>Shell Loop Types</u></h3>

-> A loop is a powerful programming tool that enables you to execute a set of commands repeatedly. 
-> We will examine the following types of loops available to shell programmers −

a. The while loop
b. The for loop
c. The until loop
d. The select loop

-> You will use different loops based on the situation. 
-> For example, the while loop executes the given commands until the given condition remains true.
-> The until loop executes until a given condition becomes true.

<u>The while Loop</u>

-> The while loop enables you to execute a set of commands repeatedly until some condition occurs. 
-> It is usually used when you need to manipulate the value of a variable repeatedly.

Syntax:

while command
do
   Statement(s) to be executed if command is true
done

<h3><u>The for Loop</u></h3>

-> The for loop operates on lists of items. 
-> It repeats a set of commands for every item in a list.

Syntax:

for var in word1 word2 ... wordN
do
   Statement(s) to be executed for every word.
done

<h3><u>The until Loop</u></h3>

-> The while loop is perfect for a situation where you need to execute a set of commands while some condition is true. 
-> Sometimes you need to execute a set of commands until a condition is true.

Syntax:

until command
do
   Statement(s) to be executed until command is true
done

-> If the resulting value is false, given statement(s) are executed. 
-> If the command is true then no statement will be executed and the program jumps to the next line after the done statement.



<u>Nesting Loops</u>
-> All the loops support nesting concept which means you can put one loop inside another similar one or different loops. 
-> This nesting can go up to unlimited number of times based on your requirement.
-> Here is an example of nesting while loop. The other loops can be nested based on the programming requirement in a similar way −
-> Nesting while Loops - It is possible to use a while loop as part of the body of another while loop.

Syntax
while command1 ; # this is loop1, the outer loop
do
   Statement(s) to be executed if command1 is true

   while command2 ; # this is loop2, the inner loop
   do
      Statement(s) to be executed if command2 is true
   done

   Statement(s) to be executed if command1 is true
done
Example
Here is a simple example of loop nesting. Let's add another countdown loop inside the loop that you used to count to nine −

#!/bin/sh

a=0
while [ "$a" -lt 10 ]    # this is loop1
do
   b="$a"
   while [ "$b" -ge 0 ]  # this is loop2
   do
      echo -n "$b "
      b=`expr $b - 1`
   done
   echo
   a=`expr $a + 1`
done
This will produce the following result. It is important to note how echo -n works here. Here -n option lets echo avoid printing a new line character.

0
1 0
2 1 0
3 2 1 0
4 3 2 1 0
5 4 3 2 1 0
6 5 4 3 2 1 0
7 6 5 4 3 2 1 0
8 7 6 5 4 3 2 1 0
9 8 7 6 5 4 3 2 1 0

=========================================
1. WAP on all the operators (Arithmetic, Relational, Boolean, String, File test)
2. WAP for an average.
3. WAP to find average using for loop.
4. WAP to find even number from the list.
5. WAP for palindrome.
6. WAP for Fibonacci series. 
7. WAP for patterns
8. WAP to compare 5 pair of numbers using function.
9. WAP to find the average of array and return the avg value.
10. WAP which takes arguments and find the average. 
</h4>
</pre></html>  